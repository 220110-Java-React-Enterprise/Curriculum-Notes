# Java Compilation
"Compilation" is a term that refers to the process of turning your source code into executable instructions (often called binaries). In the early days of programming compilation was one small set in a larger pipeline from source to binary. Now days we sort of include all of the steps into the blanket term "compile". You may also see people say "build". this is the same idea, and probably a more accurate term.
  
Many programming languages produce executable files when built, however Java does not. Executable files are binary files that contain a series of CPU instructions, called machine code. In this way your program is able to tell the CPU what to do. Java doesn't do this directly, instead Java produces bytecode when compiled. This bytecode, similar to machine code, contains instructions for the Java virtual Machine, which then in turn tells the CPU what to do. This is how Java can be run on so many platforms. All of the bytecode is the same, regardless of target environment. As long as there is a JVM present to interpret bytecode and convert it into machine instructions, Java programs can be run there.
  
## Compile/Build Steps:
First, the source ‘.java’ file is passed through the compiler, which then encodes the source code into a machine-independent encoding, known as Bytecode. The content of each class contained in the source file is stored in a separate ‘.class’ file. While converting the source code into the bytecode, the compiler follows the following steps:

1. **Parse**: Reads a set of *.java source files and maps the resulting token sequence into AST (Abstract Syntax Tree)-Nodes.
2. **Enter**: Enters symbols for the definitions into the symbol table.
3. **Process** annotations: If Requested, processes annotations found in the specified compilation units.
4. **Attribute**: Attributes the Syntax trees. This step includes name resolution, type checking and constant folding.
5. **Flow**: Performs dataflow analysis on the trees from the previous step. This includes checks for assignments and reachability.
6. **Desugar**: Rewrites the AST and translates away some syntactic sugar.
7. **Generate**: Generates ‘.Class’ files. 

## Execution:

The class files generated by the compiler are independent of the machine or the OS, which allows them to be run on any system. To run, the main class file (the class that contains the method main) is passed to the JVM and then goes through three main stages before the final machine code is executed. These stages are:
These states do include:

1. ClassLoader
2. Bytecode Verifier
3. Just-In-Time Compiler



### Stage 1: Class Loader

The main class is loaded into the memory bypassing its ‘.class’ file to the JVM, through invoking the latter. All the other classes referenced in the program are loaded through the class loader.
A class loader, itself an object, creates a flat namespace of class bodies that are referenced by a string name. The method definition is provided below illustration as follows:

Illustration:
```java
// loadClass function prototype

Class r = loadClass(String className, boolean resolveIt);

// className: name of the class to be loaded
// resolveIt: flag to decide whether any referenced class should be loaded or not.
```

There are two types of class loaders

 - primordial
 - non-primordial
The primordial class loader is embedded into all the JVMs and is the default class loader. A non-primordial class loader is a user-defined class loader, which can be coded in order to customize the class-loading process. Non-primordial class loader, if defined, is preferred over the default one, to load classes. 

### Stage 2: Bytecode Verifier

After the bytecode of a class is loaded by the class loader, it has to be inspected by the bytecode verifier, whose job is to check that the instructions don’t perform damaging actions. The following are some of the checks carried out: 

 - Variables are initialized before they are used.
 - Method calls match the types of object references.
 - Rules for accessing private data and methods are not violated.
 - Local variable accesses fall within the runtime stack.
 - The run-time stack does not overflow.
 - If any of the above checks fail, the verifier doesn’t allow the class to be loaded.


### Stage 3: Just-In-Time Compiler

This is the final stage encountered by the java program, and its job is to convert the loaded bytecode into machine code. When using a JIT compiler, the hardware can execute the native code, as opposed to having the JVM interpret the same sequence of bytecode repeatedly and incurring the penalty of a relatively lengthy translation process. This can lead to performance gains in the execution speed unless methods are executed less frequently.

![Java compilation and Class Loading](./../images/java-compilation.jpg)
